# 表达式

* 可以取地址的，有名字的，非临时的就是左值；(glvalue - xvalue)
* 不能取地址的，没有名字的，临时的就是右值；(prvalue + xvalue)

## 表达式基础

* 运算对象转换：小整数类型会被提升为较大的整数类型
* 重载运算符：当运算符作用在类类型的运算对象时，用户可以自行定义其含义。
* 左值和右值：
  * C：左值**可以**在赋值语句左边，右值不能。
  * C++：当一个对象被用作**右值**的时候，用的是对象的**值**（内容）。被用做**左值**时，用的是对象的**身份**（在内存中的位置）。
* **求值顺序**：`int i = f1() + f2()`
  * 先计算`f1() + f2()`,再计算`int i = f1() + f2()`。但是f1和f2的计算**先后不确定**
  * 但是，如果f1、f2都对同一对象进行了修改，因为顺序不确定，所以会编译出错，显示未定义 （`cout << i << ++i << endl;` 不确定 `i` 和 `++i` 执行顺序）
  * 只有四种运算符规定了求值顺序 `&&` `||` `?:` `,`

## 算术运算符

* 左结合
* 结果是右值
* bool 不应参与算数运算
* 取余运算m%n，结果符号与m相同

## 逻辑运算符

* 短路求值 **先左再右**
* TIPS ： 声明为引用类型可以避免对元素的拷贝，如下，如string特别大时可以节省大量时间。

```cpp
vector<string> text;
for(const auto &s: text){
  cout<<s;
}
```

## 赋值运算符

* 赋值运算左侧运算对象必须是个左值。
* `(i = get_value()) != 42` 和 `i = get_value() != 42` 的区别
* 复合运算符 例如 `+=` ： `a op= b` 等价于 `a = a op b`

## 递增递减

* 除非必要，不使用递增递减的后置版本 `i++`：后置版本需要将原始值存储下来，返回
* `*point++` 遍历

后置版本递增递减表达式执行是右值，前置递增递减将对象作为左值返回。

## 成员访问符号

`prt->mem` 等价于 `(*ptr).mem`

## expr ? if_true_expr : if_false_expr

## 类型转换

### 隐式类型转换

### 显式类型转换

#### C风格显示类型转换

#### const_cast

在有不同 cv 限定的类型间转换。改变底层 const。

#### static_cast

将类型A转换成类型B，可能出现损失或者未定义行为

#### reinterpret_cast

改变底层位数据的解释
